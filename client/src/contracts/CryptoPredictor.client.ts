/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, BetDirection, Coin, QueryMsg, Addr, PredictionResponse } from "./CryptoPredictor.types";
export interface CryptoPredictorReadOnlyInterface {
  contractAddress: string;
  getPrediction: ({
    predictionId
  }: {
    predictionId: number;
  }) => Promise<PredictionResponse>;
}
export class CryptoPredictorQueryClient implements CryptoPredictorReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getPrediction = this.getPrediction.bind(this);
  }
  getPrediction = async ({
    predictionId
  }: {
    predictionId: number;
  }): Promise<PredictionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_prediction: {
        prediction_id: predictionId
      }
    });
  };
}
export interface CryptoPredictorInterface extends CryptoPredictorReadOnlyInterface {
  contractAddress: string;
  sender: string;
  submitPrediction: ({
    betAmount,
    prediction,
    symbol
  }: {
    betAmount: Coin;
    prediction: number;
    symbol: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  finalizePrediction: ({
    actualPrice,
    predictionId
  }: {
    actualPrice: number;
    predictionId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePrice: ({
    newPrice,
    symbol
  }: {
    newPrice: Uint128;
    symbol: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  startRound: ({
    startPrice,
    symbol
  }: {
    startPrice: Uint128;
    symbol: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  endRound: ({
    endPrice,
    roundId
  }: {
    endPrice: Uint128;
    roundId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  placeBet: ({
    amount,
    direction,
    roundId
  }: {
    amount: Uint128;
    direction: BetDirection;
    roundId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class CryptoPredictorClient extends CryptoPredictorQueryClient implements CryptoPredictorInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.submitPrediction = this.submitPrediction.bind(this);
    this.finalizePrediction = this.finalizePrediction.bind(this);
    this.updatePrice = this.updatePrice.bind(this);
    this.startRound = this.startRound.bind(this);
    this.endRound = this.endRound.bind(this);
    this.placeBet = this.placeBet.bind(this);
  }
  submitPrediction = async ({
    betAmount,
    prediction,
    symbol
  }: {
    betAmount: Coin;
    prediction: number;
    symbol: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_prediction: {
        bet_amount: betAmount,
        prediction,
        symbol
      }
    }, fee, memo, _funds);
  };
  finalizePrediction = async ({
    actualPrice,
    predictionId
  }: {
    actualPrice: number;
    predictionId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      finalize_prediction: {
        actual_price: actualPrice,
        prediction_id: predictionId
      }
    }, fee, memo, _funds);
  };
  updatePrice = async ({
    newPrice,
    symbol
  }: {
    newPrice: Uint128;
    symbol: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_price: {
        new_price: newPrice,
        symbol
      }
    }, fee, memo, _funds);
  };
  startRound = async ({
    startPrice,
    symbol
  }: {
    startPrice: Uint128;
    symbol: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      start_round: {
        start_price: startPrice,
        symbol
      }
    }, fee, memo, _funds);
  };
  endRound = async ({
    endPrice,
    roundId
  }: {
    endPrice: Uint128;
    roundId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      end_round: {
        end_price: endPrice,
        round_id: roundId
      }
    }, fee, memo, _funds);
  };
  placeBet = async ({
    amount,
    direction,
    roundId
  }: {
    amount: Uint128;
    direction: BetDirection;
    roundId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      place_bet: {
        amount,
        direction,
        round_id: roundId
      }
    }, fee, memo, _funds);
  };
}